<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Max API: MC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Max API
   &#160;<span id="projectnumber">8.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('chapter_mc.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">MC </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>MC is the system for multi-voice or multi-channel audio signals introduced with Max 8.</p>
<p>MC is not an entirely new API for MSP objects. Instead it is built on top of the existing MSP API. Is it implemented as some additions to the MSP signal compiler — the code that turns a graph of MSP objects into an ordered sequence of operations on signals — to deal with patch cords that hold more than one audio signal. Multi-channel signal patch cords co-exist with regular old- school patch cords as well as Jitter and event patch cords.</p>
<p>An important principle of Max is that outlet types define patch cord types. This is how Max knows, when the user clicks on an outlet to patch something, what kind of patch cord to make. Jitter objects have “matrix” outlets. Regular Max events travel through outlets that either have no type defined or a type such as “int” or “bang.”</p>
<p>Following this principle, if you want your MSP object to have outlets that produce multi-channel signals, you will have to change the type of the outlets from signal to multichannelsignal. An outlet of type multichannelsignal will have between 1 and 512 signals in it. A patch cord coming from this type of outlet will be a special color and width, and can be connected to any MSP object, even those that don’t know about MC. (In that case, only the first channel will be used.)</p>
<h1><a class="anchor" id="chapter_mc_wrapper"></a>
The MC Wrapper</h1>
<p>What are you hoping to do to your object within the MC universe? If it’s a filter, do you want N filters, one operating on every audio channel? If that’s all you want, you can avoid doing any coding simply by whitelisting your object to use the MC wrapper. Let’s say your object is called myfilter~ and you want the N-way version to be called mc.myfilter~. Add the following message to Max in any file that is evaluated at startup (that typically means you’ll put it in the init folder):</p>
<div class="fragment"><div class="line">max objectfile mc.myfilter~ mc.wrapper~ myfilter~;</div></div><!-- fragment --><p>This establishes a mapping when the user types mc.myfilter~ into an object box. The MC wrapper looks at the name the user types, removes the “mc.” from the beginning, and looks for a Max object with the string that remains. So, this means you can’t do this:</p>
<div class="fragment"><div class="line">max objectfile myNWAYfilter~ mc.wrapper~ myfilter~;</div></div><!-- fragment --><p>The name “myfilter~” at the end of this message specifies the name of the help file to open. If you want to make a special help file for the N-way version of your object, you could do this:</p>
<div class="fragment"><div class="line">max objectfile mc.myfilter~ mc.wrapper~ mc.myfilter~;</div></div><!-- fragment --><h1><a class="anchor" id="chapter_mc_ins_and_outs"></a>
Multi-channel Inputs and Outputs</h1>
<p>Maybe your concept of MC compatibility is not related to having N copies of your object in the wrapper. For example, your object might be concerned with audio signal input or output, either to the outside world or to a file. Perhaps you simply want to accept all inputs as a single multi- channel signal (which is nice if you don’t want to decide in advance how many channels you will accept). Perhaps you want to produce a multi-channel signal instead of separate single-channel signals. Maybe your object mixed some stuff together that you realize would be nice not to mix together, so you’d like to provide each unmixed audio output together in a multi-channel patch cord.</p>
<p>For these cases, you can use the extensions to the MSP API described here. An MSP object that is MC-compatible will work in any version of Max with 64-bit floating-point. By convention, MSP objects that operate in both single-channel and multi-channel versions look at the object name symbol passed to the new instance routine and are multi-channel if the name begins with “mc.” or “mcs.” You are free to rebel against this standard and establish your own convention.</p>
<p>There are no special functions exported from Max or the MSP library specific to MC, so the only thing that will break in Max 7 and earlier versions is that your outlets won’t work because only Max 8 knows about the multichannelsignal outlet type.</p>
<h1><a class="anchor" id="chapter_mc_inlets_and_outlets"></a>
Creating Multi-channel Inlets and Outlets</h1>
<p>For multi-channel inlets, you don’t need to do anything special unless you want fewer inlets that you would otherwise. Just call <a class="el" href="group__msp.html#gad15f054306792846a00a5f4e9e5426be" title="This is commonly used rather than directly calling z_dsp_setup() in MSP objects. ">dsp_setup()</a> as you normally would and the user will be able to connect both single-channel and multi-channel patch cords. For multi-channel outlets, instead of</p>
<div class="fragment"><div class="line"><a class="code" href="group__inout.html#gac25db50a2a7eb76c5e057dd907c11d44">outlet_new</a>(x, <span class="stringliteral">&quot;signal&quot;</span>);</div></div><!-- fragment --><p>use</p>
<div class="fragment"><div class="line"><a class="code" href="group__inout.html#gac25db50a2a7eb76c5e057dd907c11d44">outlet_new</a>(x, <span class="stringliteral">&quot;multichannelsignal&quot;</span>);</div></div><!-- fragment --><h1><a class="anchor" id="chapter_mc_channelcounting"></a>
Channel Counting in the Perform Method</h1>
<p>Most of what you have to do is related to being a bit more careful about what you might previously have been able to assume about your perform method.</p>
<p>The prototype for your MSP perform method looks like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myobject_perform64(t_myobject *x, <a class="code" href="structt__object.html">t_object</a> *dsp64, <span class="keywordtype">double</span> **ins, <span class="keywordtype">long</span> numins, <span class="keywordtype">double</span> **outs, <span class="keywordtype">long</span> numouts, <span class="keywordtype">long</span> sampleframes, <span class="keywordtype">long</span> flags, <span class="keywordtype">void</span> *userparam);</div></div><!-- fragment --><p>Let’s say your object will have one multi-channel signal input and one multi-channel signal output. As you can probably guess, the numins parameter to the perform method will be the count of channels in the input and the numouts parameter will be the count of channels in the output. Now let’s consider some other cases because once we have more than one inlet and/or outlet, things get trickier.</p>
<p>Consider an object with two multi-channel inputs. You don’t know in advance how many channels will be in each signal connected to your object. It could be 1 (if the user connects an old-style patch cord). It could be 100. It could be there is no connection at all to your object. What do you do?</p>
<p>If you’re in this situation, you’ll need to ask MSP how many channels are in each input in your dsp64 method, which is called before the DSP is turned on. The prototype for your dsp64 method looks like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myobject_dsp64(t_myobject *x, <a class="code" href="structt__object.html">t_object</a> *dsp64, <span class="keywordtype">short</span> *count, <span class="keywordtype">double</span> samplerate, <span class="keywordtype">long</span> maxvectorsize, <span class="keywordtype">long</span> flags);</div></div><!-- fragment --><p>The dsp64 object passed to this method can be used to interrogate the number of channels in each of your object’s inlets via the getnuminputchannels method. If your object has two inlets, here is how you can find out how many input channels each inlet has:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myobject_dsp64(t_myobject *x, <a class="code" href="structt__object.html">t_object</a> *dsp64, <span class="keywordtype">short</span> *count, <span class="keywordtype">double</span> samplerate, <span class="keywordtype">long</span> maxvectorsize, <span class="keywordtype">long</span> flags)</div><div class="line">{</div><div class="line">    <span class="keywordtype">long</span> leftinletchannelcount, rightinletchannelcount;</div><div class="line">    leftinletchannelcount = (long)<a class="code" href="group__obj.html#gae740749094827ac5adc2b7145db1c596">object_method</a>(dsp64,<a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;getnuminputchannels&quot;</span>), x, 0);</div><div class="line">    rightinletchannelcount = (long)<a class="code" href="group__obj.html#gae740749094827ac5adc2b7145db1c596">object_method</a>(dsp64, <a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;getnuminputchannels&quot;</span>), x, 1);</div><div class="line">}</div></div><!-- fragment --><p>Note that an unconnected inlet has one channel, which, as has always been in the case in MSP, will be a signal containing all zeroes.</p>
<p>You might want to store these channel count values in your object so you can make use of them in your perform method. Then you’ll know how to interpret the ins array of audio buffers you receive.</p>
<h1><a class="anchor" id="chapter_mc_output_channelcount"></a>
Specifying Output Channel Counts</h1>
<p>The channel count for a multi-channel signal outlet is determined when MSP is building the DSP chain with the signal compiler. This means it can change each time the user turns the audio on if the graph has changed.</p>
<p>In MC, it’s important to remember that outlets, not inlets, determine signal channel counts. You report the number of channels your object’s outlets will have by supporting the multichanneloutputs method.</p>
<div class="fragment"><div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)myobject_multichanneloutputs, <span class="stringliteral">&quot;multichanneloutputs&quot;</span>, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">long myobject_multichanneloutputs(t_myobject *x, <span class="keywordtype">long</span> outletindex)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> 4;</div><div class="line">}</div></div><!-- fragment --><p>The above creates an outlet with four channels. Every time.</p>
<h1><a class="anchor" id="chapter_mc_autoadapt"></a>
How to Auto-Adapt</h1>
<p>If your object has defined multi-channel outlets it may receive the inputchanged message when the MSP signal compiler runs. This notifies your object how many channels are going to be sent to one of your object’s inlets. You don’t have to implement an inputchanged method, but you can use the information it provides to auto-adapt your object’s number of output channels in one or more of your multi-channel signal outlets. The MC Wrapper performs auto- adapting when the user does not specify a fixed number of channels. For example, if mc.cycle~ 440  64 is connected to the input of mc.*~, the wrapper will create 64 instances of a *~ object, one to multiply the output of each of the 64 cycle~ objects in the mc.cycle~.</p>
<p>Auto-adapting is a “conversational” protocol that involves both the inputchanged and multichanneloutputs methods.</p>
<p>Here’s how it works:</p>
<p>First, implement an the inputchanged method in addition to a multichannel outputs method:</p>
<div class="fragment"><div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)myobject_inputchanged, <span class="stringliteral">&quot;inputchanged&quot;</span>, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">long myobject_inputchanged(t_myobject *x, <span class="keywordtype">long</span> index, <span class="keywordtype">long</span> count)</div><div class="line">{</div><div class="line">    <span class="comment">// do something here and return true or false</span></div><div class="line">}</div></div><!-- fragment --><p>Index is the inlet index of your object (with the leftmost being zero) and count is the number of audio channels in that particular inlet.</p>
<p>Your object’s inputchanged method should return true if its idea of how many outputs one of your outlets may be changing based on the information just received. It should return false it is not going to change. Returning false is polite and optimizes the speed of compiling the signal chain.</p>
<p>You should also store the count you receive somewhere in your object if you are going to use it to modify the count of output channels. After you return true from the inputchanged method your object’s multichanneloutputs method will be called for every multichannelsignal outlet your object has created. You can then return the new channel count based on the information received in the inputchanged method.</p>
<p>Here’s an illustration of the auto-adapting protocol with a simple example of an object with one inlet and one multichannelsignal outlet. First, the object will receive the inputchanged method:</p>
<div class="fragment"><div class="line"><span class="keywordtype">long</span> myobject_inputchanged(t_myobject *x, <span class="keywordtype">long</span> index, <span class="keywordtype">long</span> count)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (count != x-&gt;m_inputcount) {</div><div class="line">        x-&gt;m_inputcount = count;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">long</span> myobject_multichanneloutputs(t_myobject *x, <span class="keywordtype">long</span> index)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> x-&gt;m_inputcount;</div><div class="line">}</div></div><!-- fragment --><p>Note that the inputchanged and multichanneloutputs methods will be sent to your object before the dsp64 method.</p>
<p>It’s a good practice to use the getnuminputchannels technique inside your object’s dsp64 method as demonstrated above even if you support the inputchanged method. The signal compiler is not guaranteed to send the inputchanged message to your object in all cases — for example, it may not send inputchanged if there is nothing connected to one of your inlets, so for determining the output count you should assume one channel until inputchanged tells you something else. (Currently the inputchanged message is sent to objects with unconnected inlets, but this adds some overhead, so we’re investigating whether it’s always necessary.)</p>
<h1><a class="anchor" id="chapter_mc_how_many"></a>
How Many Output Channels Do I Have?</h1>
<p>If you want to determine the count of signal output channels your object has for any of its multi- channel (or single-channel) outlets in your dsp64 method, you can send the message getnumoutputchannels to the dsp64 object:</p>
<div class="fragment"><div class="line"><span class="keywordtype">long</span> leftoutletchannelcount = (long)<a class="code" href="group__obj.html#gae740749094827ac5adc2b7145db1c596">object_method</a>(dsp64, <a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;getnumoutputchannels&quot;</span>), x, 0);</div></div><!-- fragment --><p>The getnumoutputchannels method of the dsp64 object works the same as the getnuminputchannels method.</p>
<p>Here’s something potentially unintuitive about the MC signal compiler: it always gives you the number of output channels you want, whether or not that’s a good idea. Here’s what this means. Suppose you have an object with two multichannelsignal outlets. In your dsp64 method, you notice that one of these outlets is not connected to anything (its entry in the count[] array is zero). You might assume this means the output channel count is zero, or maybe one (as with the number of channels given to an unconnected inlet). However, in reality it will be the number of channels you returned for this outlet in your multichanneloutputs method. The principle that applies here, established since the first version of MSP, is that you should never have to modify the behavior of your perform method based on whether its outputs are connected. You could choose not to call dsp_add64 in a case where none of your object’s outlets were connected in which case your perform method won’t be called. But if the perform method is going to be called, it will receive the number of outputs you request.</p>
<p>To summarize, if your object has two outlets and it has returned a value of 12 for each outlet in its multichanneloutputs method, the perform method will receive a total of 24 output channels (in other words, the numouts parameter will be 24).</p>
<h1><a class="anchor" id="chapter_mc_msp_inlets"></a>
Handling MC Signals in Traditional MSP Objects</h1>
<p>When an MC signal is connected to to a traditional MSP object, then only the first channel of a multi-channel patch cord is handed to the object.</p>
<p>If you want to modify this behavior and receive all of the channels the you must supply the Z_MC_INLETS flag. Having supplied this flag, a user can connect single-channel patch cords, multi-channel patch cords, or both &ndash; and you’ll have to make the best out of the situation.</p>
<h1><a class="anchor" id="chapter_mc_examples"></a>
Examples</h1>
<p>The first example is a signal visualizer called gridmeter~. It is included to demonstrate just two changes for objects receiving multi-channel inputs:</p>
<ul>
<li>First, the object checks the value returned by the getnuminputchannels method in the dsp64 method. This permits it to know how many channels to paint in the grid.</li>
<li>Second, it does not assume a specific count of channels in its perform method, which was typically the case with meter objects in MSP. Instead, it has a loop for each input channel up to the value of the numins parameter.</li>
</ul>
<p>The second example is called mc.rotate~ and demonstrates how to implement the auto-adapting protocol. mc.rotate~ simply rotates all the channels in any multi-channel signal it receives by one, but it will produce the same number of output channels as the number of inputs it receives.</p>
<p>Finally, there is also the example of mc.pack~ which takes only the first channel of any connected multi-channel signal. But if you type mc.combine~ instead it uses all the channels. mc.pack~ and mc.combine~ are the same object, but behave differently based on the convention that something called “pack” doesn’t produce more outputs than it has inlets. This demonstrates the use of the Z_MC_INLETS flag. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
